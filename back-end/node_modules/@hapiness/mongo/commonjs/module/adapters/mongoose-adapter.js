"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mongoose = require("mongoose");
const Observable_1 = require("rxjs/Observable");
const hapiness_mongo_adapter_1 = require("./hapiness-mongo-adapter");
const shared_1 = require("../shared");
const __debugger = new shared_1.Debugger('MongooseAdapter');
mongoose.Promise = global.Promise;
class MongooseAdapter extends hapiness_mongo_adapter_1.HapinessMongoAdapter {
    static getInterfaceName() {
        return 'mongoose';
    }
    constructor(options) {
        super(options);
    }
    _tryConnect() {
        return Observable_1.Observable
            .create(observer => {
            this._isReady = false;
            if (this._db) {
                __debugger.debug('_tryConnect', 'db already exists');
                this._db.close();
            }
            const connectOptions = {
                server: {
                    reconnectTries: Number.MAX_VALUE,
                    reconnectInterval: 5000,
                },
            };
            this._connection = mongoose.createConnection(this._uri, connectOptions);
            this._connection.once('connected', () => {
                __debugger.debug('_tryConnect', 'connection once connected');
                observer.next();
                observer.complete();
            });
            this._connection.once('error', err => {
                __debugger.debug('_tryConnect', `connection once error ${JSON.stringify(err, null, 2)}`);
                observer.error(err);
            });
        });
    }
    _afterConnect() {
        return Observable_1.Observable
            .create(observer => {
            this._db = this._connection.db;
            this.onConnected().subscribe(_ => {
                __debugger.debug('_afterConnect', '(subscribe) On connected success');
            }, (e) => {
                __debugger.debug('_afterConnect', `(subscribe) On connected failed ${JSON.stringify(e, null, 2)}`);
            });
            this._connection.once('error', err => this.onError(err).subscribe(_ => {
                __debugger.debug('_afterConnect', '(subscribe) On connection error #success');
            }, (e) => {
                __debugger.debug('_afterConnect', `(subscribe) On connection error #failed ${JSON.stringify(e, null, 2)}`);
            }));
            this._connection.once('disconnected', () => this.onDisconnected().subscribe(_ => {
                __debugger.debug('_afterConnect', '(subscribe) On connection disconnected #success');
            }, (e) => {
                __debugger.debug('_afterConnect', `(subscribe) On connection disconnected #failed ${JSON.stringify(e, null, 2)}`);
            }));
            observer.next();
            observer.complete();
        });
    }
    getLibrary() {
        return mongoose;
    }
    registerValue(schema, collection) {
        return this._connection.model(collection, schema);
    }
}
exports.MongooseAdapter = MongooseAdapter;
//# sourceMappingURL=mongoose-adapter.js.map
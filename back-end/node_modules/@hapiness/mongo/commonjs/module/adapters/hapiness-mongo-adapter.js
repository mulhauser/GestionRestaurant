"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const model_manager_1 = require("../managers/model-manager");
const events_1 = require("events");
const Observable_1 = require("rxjs/Observable");
const shared_1 = require("../shared");
const __debugger = new shared_1.Debugger('HapinessMongoAdapter');
/*
 * Not really abstract but we'll simulate it
 */
class HapinessMongoAdapter extends events_1.EventEmitter {
    static getInterfaceName() {
        throw new Error('Your adapter should implements `getInterfaceName()`');
    }
    constructor(options) {
        super();
        this._config = options;
        // It means we're not on test environment but we dont get any config!
        if (!this._config || !Object.keys(this._config).length) {
            throw new Error('Missing mongodb configuration');
        }
        this._isReady = false;
        if (options.skip_connect) {
            return;
        }
        this._modelManager = new model_manager_1.ModelManager();
        this
            .connect()
            .subscribe(_ => {
            __debugger.debug('constructor', 'OK');
        }, (err) => {
            __debugger.debug('constructor', `Err catched :: ${err.message}`);
            __debugger.debug('constructor', `Err catched :: ${JSON.stringify(err, null, 2)}`);
        });
    }
    connect() {
        this._connection = null;
        const db = this._config.db || this._config.database;
        if (this._config.url) {
            this._uri = shared_1.UtilFunctions.getMongoUri(this._config.url, db);
        }
        else if (!!db) {
            this._uri = `mongodb://${this._config.host}:${this._config.port || 27017}/${db}`;
        }
        else {
            return Observable_1.Observable.throw(new Error('No db name nor url provided'));
        }
        return this.tryConnect();
    }
    tryConnect() {
        return this
            ._tryConnect()
            .switchMap(_ => this._afterConnect());
    }
    /*
     *
     *  This function should be overriden by all inherited classes.
     *
     */
    _tryConnect() {
        return Observable_1.Observable
            .throw(new Error('`_tryConnect` is not implemented'));
    }
    /*
     *
     *  This function should be overriden by all inherited classes.
     *
     */
    _afterConnect() {
        return Observable_1.Observable
            .throw(new Error('`_afterConnect` is not implemented'));
    }
    /*
     *
     *  This function should be overriden by all inherited classes.
     *
     */
    getLibrary() {
        throw new Error('`getLibrary` is not implemented');
    }
    /*
     *
     *  This function should be overriden by all inherited classes.
     *
     */
    registerValue(schema, collection) {
        throw new Error('`registerValue` is not implemented');
    }
    getModelManager() {
        return this._modelManager;
    }
    onConnected() {
        __debugger.debug('onConnected', '');
        return Observable_1.Observable
            .create(observer => {
            this._isReady = true;
            this.emit('ready');
            observer.next();
            observer.complete();
        });
    }
    onDisconnected() {
        __debugger.debug('onDisconnected', '');
        this.emit('disconnected');
        return this
            .tryConnect()
            .delay(5000);
    }
    onError(err) {
        __debugger.debug('onError', `got error :: ${JSON.stringify(err, null, 2)}`);
        return this
            .tryConnect()
            .delay(5000);
    }
    whenReady(options = { timeout: 60000 }) {
        return Observable_1.Observable
            .create(observer => {
            if (this._isReady) {
                __debugger.debug('whenReady', 'already ready');
                observer.next();
                observer.complete();
                return;
            }
            this.once('ready', () => {
                __debugger.debug('whenReady', 'now ready');
                this._isReady = true;
                observer.next();
                observer.complete();
            });
        })
            .timeout(options.timeout);
    }
    isConnected() {
        return this.isReady();
    }
    isReady() {
        return this._isReady;
    }
    getUri() {
        return this._uri;
    }
    getConnection() {
        return this._connection;
    }
}
exports.HapinessMongoAdapter = HapinessMongoAdapter;
//# sourceMappingURL=hapiness-mongo-adapter.js.map
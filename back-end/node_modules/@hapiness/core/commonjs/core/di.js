"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const injection_js_1 = require("injection-js");
const logger_1 = require("./logger");
const rxjs_1 = require("rxjs");
class DependencyInjection {
    /**
     * Create a new DI and
     * can inherits from a parent DI
     *
     * @param  {Type<T>[]} providers
     * @param  {ReflectiveInjector} parent?
     * @returns Observable<ReflectiveInjector>
     */
    static createAndResolve(providers, parent) {
        return rxjs_1.Observable
            .of(parent)
            .map(_ => !!_ ?
            parent.resolveAndCreateChild(providers) :
            injection_js_1.ReflectiveInjector.resolveAndCreate(providers))
            .do(_ => this.logger.debug(`DI created, providers: ${providers.length}`));
    }
    /**
     * Instantiate a component
     * resolving its dependencies
     * without inject the component
     * into the DI
     *
     * @param  {Type<T>} component
     * @param  {ReflectiveInjector} di
     * @returns T
     */
    static instantiateComponent(component, di) {
        return rxjs_1.Observable
            .from(injection_js_1.ReflectiveInjector.resolve([component]))
            .reduce((a, x) => a.concat(x.resolvedFactories), [])
            .map(_ => _.reduce((a, r) => a.concat(r.dependencies), []))
            .map(_ => _.filter(__ => !!__))
            .do(_ => this.logger.debug(`Component '${component.name}' deps: ${_.length}`))
            .map(_ => _.map(d => di['_getByReflectiveDependency'](d)))
            .map(_ => Reflect.construct(component, _));
    }
}
DependencyInjection.logger = new logger_1.InternalLogger('di');
exports.DependencyInjection = DependencyInjection;
//# sourceMappingURL=di.js.map
{"version":3,"file":"hook.js","sourceRoot":"","sources":["../../../src/core/hook.ts"],"names":[],"mappings":";;AAAA,+BAAkC;AAClC,6CAAoC;AACpC,qCAA0C;AAE1C;IAII;;;;;;OAMG;IACI,MAAM,CAAC,gBAAgB,CAAI,IAAY,EAAE,KAAc;QAC1D,MAAM,CAAC,KAAK,YAAY,iBAAI,IAAI,IAAI,IAAI,KAAK,CAAC,SAAS,CAAC;IAC5D,CAAC;IAED;;;;;;;;;;OAUG;IACI,MAAM,CAAC,WAAW,CAAI,IAAY,EAAE,KAAgB,EAAE,QAAW,EAAE,IAAY,EAAE,QAAkB;QACtG,MAAM,CAAC,iBAAU;aACZ,KAAK,CACF,iBAAU;aACL,EAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;aACtC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;aAChB,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAE,IAAI,IAAI,EAAE,CAAC,CAAC;aAC7D,OAAO,CAAC,CAAC,CAAC,EAAE,CACT,CAAC,CAAC,YAAY,iBAAU,CAAC,CAAC,CAAC;YAC3B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACT,iBAAU,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;YAClB,iBAAU,CAAC,KAAK,EAAE,CACrB,EAEL,iBAAU;aACL,EAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;aACtC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC;aAC3B,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,iBAAU,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,gBAAgB,IAAI,OAAO,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAC1F;aACA,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,oBAAoB,IAAI,SAAS,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;IACpF,CAAC;;AA5Cc,kBAAM,GAAG,IAAI,uBAAc,CAAC,MAAM,CAAC,CAAC;AAFvD,kCA+CC","sourcesContent":["import { Observable } from 'rxjs';\nimport { Type } from './decorators';\nimport { InternalLogger } from './logger';\n\nexport class HookManager {\n\n    private static logger = new InternalLogger('hook');\n\n    /**\n     * Check if a token has a hook implemented\n     *\n     * @param  {string} hook\n     * @param  {Type} token\n     * @returns boolean\n     */\n    public static hasLifecycleHook<T>(hook: string, token: Type<T>): boolean {\n        return token instanceof Type && hook in token.prototype;\n    }\n\n    /**\n     * Trigger the hook if\n     * it is implemented\n     *\n     * @param  {string}   hook\n     * @param  {Type}     token\n     * @param  {T}        instance\n     * @param  {any[]}    args\n     * @param  {boolean}  throwErr\n     * @returns Observable\n     */\n    public static triggerHook<T>(hook: string, token: Type<any>, instance: T, args?: any[], throwErr?: boolean): Observable<any> {\n        return Observable\n            .merge(\n                Observable\n                    .of(this.hasLifecycleHook(hook, token))\n                    .filter(_ => !!_)\n                    .map(_ => Reflect.apply(instance[hook], instance, args || []))\n                    .flatMap(_ =>\n                        (_ instanceof Observable) ?\n                        _ : !!_ ?\n                        Observable.of(_) :\n                        Observable.empty()\n                    ),\n\n                Observable\n                    .of(this.hasLifecycleHook(hook, token))\n                    .filter(_ => !_ && throwErr)\n                    .flatMap(_ => Observable.throw(new Error(`Hook missing ${hook} on ${token.name}`)))\n            )\n            .do(_ => this.logger.debug(`Triggering hook '${hook}' on '${token.name}'`));\n    }\n}\n"]}
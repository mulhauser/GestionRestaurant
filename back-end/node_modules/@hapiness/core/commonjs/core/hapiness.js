"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const logger_1 = require("./logger");
const enums_1 = require("./enums");
const module_1 = require("./module");
const hook_1 = require("./hook");
class Hapiness {
    /**
     * Entrypoint to bootstrap a module
     * will load the extentions and trigger
     * module's hooks
     *
     * @param  {Type<any>} module
     * @param  {Array<Type<any>|ExtensionWithConfig>} extensions?
     * @returns Promise
     */
    static bootstrap(module, extensions) {
        return new Promise((resolve, reject) => {
            this
                .checkArg(module)
                .flatMap(_ => module_1.ModuleManager.resolve(_))
                .flatMap(_ => this.loadExtensions(extensions, _))
                .ignoreElements()
                .subscribe(null, _ => reject(_), () => resolve());
        });
    }
    /**
     * Load extensions
     *
     * @param  {Array<Type<any>|ExtensionWithConfig>} extensions
     * @param  {CoreModule} moduleResolved
     * @returns Observable
     */
    static loadExtensions(extensions, moduleResolved) {
        return rxjs_1.Observable
            .from([].concat(extensions).filter(_ => !!_))
            .map(_ => this.toExtensionWithConfig(_))
            .flatMap(_ => this.loadExtention(_, moduleResolved))
            .toArray()
            .do(_ => this.extensions = _)
            .flatMap(_ => this.instantiateModule(_, moduleResolved));
    }
    /**
     * Instantiate module
     *
     * @param  {Extension[]} extensionsLoaded
     * @param  {CoreModule} moduleResolved
     * @returns Observable
     */
    static instantiateModule(extensionsLoaded, moduleResolved) {
        return rxjs_1.Observable
            .from(extensionsLoaded)
            .map(_ => ({ provide: _.token, useValue: _.value }))
            .toArray()
            .flatMap(_ => module_1.ModuleManager.instantiate(moduleResolved, _))
            .flatMap(_ => this.callRegister(_))
            .flatMap(moduleInstantiated => rxjs_1.Observable
            .from(extensionsLoaded)
            .flatMap(_ => this.moduleInstantiated(_, moduleInstantiated))
            .toArray()
            .map(_ => moduleInstantiated))
            .do(_ => this.module = _)
            .flatMap(_ => this.callStart(_));
    }
    /**
     * Call Register Hooks
     *
     * @param  {CoreModule} moduleInstantiated
     * @returns Observable
     */
    static callRegister(moduleInstantiated) {
        return rxjs_1.Observable
            .from(module_1.ModuleManager.getModules(moduleInstantiated))
            .filter(_ => _.level !== enums_1.ModuleLevel.ROOT)
            .filter(_ => hook_1.HookManager
            .hasLifecycleHook(enums_1.ModuleEnum.OnRegister.toString(), _.token))
            .flatMap(_ => hook_1.HookManager
            .triggerHook(enums_1.ModuleEnum.OnRegister.toString(), _.token, _.instance))
            .toArray()
            .map(_ => moduleInstantiated);
    }
    /**
     * Call Start Hooks
     *
     * @param  {CoreModule} moduleInstantiated
     * @returns Observable
     */
    static callStart(moduleInstantiated) {
        return rxjs_1.Observable
            .of(moduleInstantiated)
            .flatMap(_ => hook_1.HookManager
            .triggerHook(enums_1.ModuleEnum.OnStart.toString(), moduleInstantiated.token, moduleInstantiated.instance, null, false));
    }
    /**
     * Check if the provided module
     * is right
     *
     * @param  {Type<any>} module
     * @returns Observable
     */
    static checkArg(module) {
        return rxjs_1.Observable
            .of(module)
            .do(_ => this.module = null)
            .do(_ => this.extensions = null)
            .flatMap(_ => !!_ ?
            rxjs_1.Observable.of(_) :
            rxjs_1.Observable.throw(new Error('Bootstrap failed: no module provided')))
            .flatMap(_ => typeof _ === 'function' ?
            rxjs_1.Observable.of(_) :
            rxjs_1.Observable.throw(new Error('Bootstrap failed: module must be a function/class')));
    }
    /**
     * Convert an extension type to ExtensionWithConfig
     *
     * @param  {} extension
     * @returns ExtensionWithConfig
     */
    static toExtensionWithConfig(extension) {
        if (extension && extension.token) {
            return extension;
        }
        return {
            token: extension,
            config: {}
        };
    }
    /**
     * Call the OnExtensionLoad hook
     * of an extension
     *
     * @param  {ExtensionWithConfig} extension
     * @returns Observable
     */
    static loadExtention(extension, module) {
        return rxjs_1.Observable
            .of(Reflect.construct(extension.token, []))
            .do(_ => this.logger.debug(`loading ${extension.token.name}`))
            .switchMap(instance => hook_1.HookManager
            .triggerHook(enums_1.ExtentionHooksEnum.OnExtensionLoad.toString(), extension.token, instance, [module, extension.config]));
    }
    /**
     * Call the OnModuleInstantiated hook
     * of an extension
     *
     * @param  {Extension} extension
     * @returns Observable
     */
    static moduleInstantiated(extension, module) {
        return hook_1.HookManager
            .triggerHook(enums_1.ExtentionHooksEnum.OnModuleInstantiated.toString(), extension.token, extension.instance, [module, extension.value])
            .do(_ => this.logger.debug(`moduleInstantiated ${extension.token.name}`))
            .defaultIfEmpty(null);
    }
}
Hapiness.logger = new logger_1.InternalLogger('bootstrap');
exports.Hapiness = Hapiness;
/**
 * Error handler
 * Call onError of Root module
 * Or log in console
 *
 * @param  {Error} error
 * @param  {any} data
 * @returns void
 */
function errorHandler(error, data) {
    rxjs_1.Observable
        .of(Hapiness['module'])
        .filter(_ => !!(_ && _.instance))
        .flatMap(_ => hook_1.HookManager
        .hasLifecycleHook(enums_1.ModuleEnum.OnError.toString(), _.token) ?
        hook_1.HookManager
            .triggerHook(enums_1.ModuleEnum.OnError.toString(), _.token, _.instance, [error, data], false) :
        rxjs_1.Observable
            .throw(error))
        .subscribe(null, _ => console.error(_));
}
exports.errorHandler = errorHandler;
//# sourceMappingURL=hapiness.js.map
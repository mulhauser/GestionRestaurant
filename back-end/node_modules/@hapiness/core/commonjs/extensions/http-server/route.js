"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const metadata_1 = require("../../core/metadata");
const di_1 = require("../../core/di");
class HttpRequestInfo {
}
exports.HttpRequestInfo = HttpRequestInfo;
class RouteBuilder {
    /**
     * Entrypoint to build a CoreRoute
     * Get the metadata and build the
     * route instance
     *
     * @param  {CoreModule} module
     * @returns CoreRoute
     */
    static buildRoutes(module) {
        return rxjs_1.Observable
            .of(module)
            .filter(_ => !!_)
            .flatMap(_ => this.metadataFromDeclarations(_.declarations))
            .flatMap(_ => this.coreRouteFromMetadata(_.route, _.token, module));
    }
    /**
     * Instantiate a new Route
     * with its own DI/request
     *
     * @param  {CoreRoute} route
     * @param  {Request} request
     * @returns Observable
     */
    static instantiateRouteAndDI(route, request) {
        return rxjs_1.Observable
            .of(request)
            .map(_ => ({
            query: Object.assign({}, request.query),
            params: Object.assign({}, request.params),
            headers: Object.assign({}, request.headers),
            payload: Object.assign({}, request.payload),
            id: request.id
        }))
            .map(_ => ({ provide: HttpRequestInfo, useValue: _ }))
            .map(_ => [].concat(route.providers).concat(_))
            .flatMap(_ => di_1.DependencyInjection.createAndResolve(_, route.module.di))
            .flatMap(_ => di_1.DependencyInjection.instantiateComponent(route.token, _));
    }
    /**
     * Transform metadata to instance CoreRoute
     *
     * @param  {Route} data
     * @returns CoreRoute
     */
    static coreRouteFromMetadata(data, token, module) {
        return rxjs_1.Observable
            .of(data)
            .flatMap(_ => rxjs_1.Observable
            .from([].concat(_.method))
            .map(__ => __.toLowerCase())
            .toArray()
            .map(__ => ({ data: _, methods: __ })))
            .map(_ => ({
            token,
            module,
            config: _.data.config,
            path: _.data.path,
            method: _.methods,
            providers: []
                .concat(_.data.providers)
                .filter(p => !!p)
                .map(p => p.provide ? p : { provide: p, useClass: p })
        }));
    }
    /**
     * Extract metadata filtered by route
     * from the declarations provided
     *
     * @param  {Type<any>} declarations
     * @returns Route
     */
    static metadataFromDeclarations(declarations) {
        return rxjs_1.Observable
            .from([].concat(declarations))
            .filter(_ => !!_ && !!metadata_1.extractMetadataByDecorator(_, this.decoratorName))
            .map(_ => ({ token: _, route: metadata_1.extractMetadataByDecorator(_, this.decoratorName) }));
    }
}
/**
 * Helper to extract metadata
 * @property {string} decoratorName
 */
RouteBuilder.decoratorName = 'Route';
exports.RouteBuilder = RouteBuilder;
//# sourceMappingURL=route.js.map